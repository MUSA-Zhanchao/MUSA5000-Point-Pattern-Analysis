---
title: 'The Spatial Distribution of Farmers Markets in Philadelphia'
author: "Zhanchao Yang, Haoyu Zhu, Kavana Raju"
date: "`r Sys.Date()`"
output:
  html_document:
    theme: flatly
    highlight: tango
    toc: true
    toc_float: true
    code_folding: hide
    code_download: yes
    mathjax: default
---
```{r load packages, message=FALSE, warning=FALSE, include=FALSE}

options(scipen=999)
options(digits = 3)

library(tidyverse)
library(sf)
library(here)
library(kableExtra)
library(patchwork)
library(spatstat.explore)
library(spatstat)
library(proxy)
```

```{r, include=FALSE}
market <- read_sf("data/Philadelphia_Farmers_Markets201302.shp")
zipcode <- read_sf("data/Philadelphia_ZipCodes.shp")
philly <- read_sf("data/Philadelphia.shp")
```


# Introduction

Access to fresh and healthy food is a critical issues in many American cities. Lack of access to fresh food may lead to significant public health challenges and worsen health disparities. In Philadelphia, the Food Trust has established a network of farmers markets to improve access to fresh food. However, some neighborhoods may still face limited or no access to these markets, raising significant concerns about the potential food desert and access inequity. This study aims to analyze the spatial distribution of farmers markets in Philadelphia to determine whether they are randomly placed, clustered, or dispersed across the city. At the same time, the study also try to identify the areas lack of access to farmers markets and the potential food deserts.

# Methodology

## Hypothesis Testing

To set up the hypothesis for our analysis, first, we need to understand the concept of completely spatially random (CSR)

### Completely Spatially Random (CSR) 

A point pattern is considered to be **Completely Spatially Random (CSR)** if the points are distributed without any discernible pattern, which means their placement is entirely random. CSR serves as a baseline model in spatial clustering analysis, allowing researchers determine whether a distribution is random or exhibits clustering or dispersion. It often used as a null hypothesis in point pattern analysis to assess deviations in spatial distributions.

To establish that a point pattern is CSR, two critical conditions must be met:

- **Equal probability of placement**: the probability of a point landing in any location within the study area must be directly proportional to the size of that location. This means that larger areas should have a higher likelihood of containing points, while smaller areas should have a lower likelihood. If the areas are divided into equal-size cells, each cell should have an equal likelihood of containing a point. For instance, if a region is divided into 60 cells of equal area, the probability of a point being in any one cell should be 1/60.
- **independence of points**: the placement of points must be independent of one another. This means that the presence of one point does not influence the likelihood of another point being placed nearby. In other words, the location of one point has no influence on where other points land, ensuring that no clustering or repulsion occurs.

Together, these two conditions, **equal probability of placement** and **independence of points**, ensure that the point pattern is completely random. If either condition is violated, the point pattern may exhibit clustering or dispersion, indicating that the points are not randomly distributed.

### Null hypothesis & Alternative hypothesis

For our point pattern analysis, the null hypothesis $H_0$ is shown as followed:

$$
H_0: \text{The point pattern of farmer's market in Philadelphia follows completely spatially random.}
$$
This implies that points are equally likely distributed anywhere within the study area, with no preference for specific locations. In addition, the placement of one point does not influence the placement of other points. CSR assumes no clustering or systematic spacing between points, which is the default or baseline spatial distribution.

On the other hand, the alternative hypothesis $H_a$ is:
$$
H_a: \text{The point pattern of farmer's market in Philadelphia exhibits clustering or dispersion.}
$$
Clusterings occurs when points are concentrated in specific areas, reflecting an underlying attraction between points, such as hotspots of activity. Dispersion, on the other hand, occurs when points are evenly spaced apart, indicating a repulsion effect or avoidance behavior. In this case, the point pattern does not follow CSR.

## The Quadrant Test

# Results

```{r, message=FALSE, warning=FALSE}
ggplot() +
  geom_sf(data = philly, fill = "grey80") +
  geom_sf(data = zipcode, fill = NA, color = "white") +
  geom_sf(data = market, color = "#c44536", size = 1.5) +
  theme(
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        plot.title = element_text(size = 12, face = "bold"),
        panel.background = element_blank(),
        panel.border = element_rect(colour = "grey", fill=NA, size=0.4)
        ) +
  labs(title = "Farmers Markets in Philadelphia")
```
```{r, warning=FALSE, message=FALSE}
philly_window <- as.owin(st_transform(philly, crs = st_crs(market)))
market_coords <- st_coordinates(market)
market_pp <- ppp(x = market_coords[,1], y = market_coords[,2], window = philly_window)
```

```{r}
# Nearest neighbor analysis
nnd <- nndist.ppp(market_pp)

# Average Observed Distance
MeanObsDist <- mean(nnd)

# Average Expected Distance
# The expected mean nearest neighbor distance under Complete Spatial Randomness (CSR).
n <- npoints(market_pp)
area <- area.owin(market_pp$window)
MeanExpDist <- 0.5 / sqrt(n / area)

#Standard Error
SE <- 0.26136 / sqrt(n*n / area)
```

```{r}
NNI <- MeanObsDist / MeanExpDist # Nearest Neighbor Index
zscore <- (MeanObsDist - MeanExpDist)/SE  #Calculating the z-score
pval<-ifelse(zscore > 0, 1 - pnorm(zscore), pnorm(zscore))  #Calculating the p-value

results <- data.frame(
  Metric = c("Nearest Neighbor Index (NNI)", "Z-Score", "P-Value"),
  Value = c(round(NNI, 3), round(zscore, 3), round(pval, 7))
)

results %>%
  kable("html", col.names = c("Metric", "Value")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```
```{r}
max.distance <- max(proxy::dist(
  data.frame(cbind(x = market_coords[,1], y = market_coords[,2])),
  data.frame(cbind(x = market_coords[,1], y = market_coords[,2])),
  method = "euclidean"
))

cat("Maximum Distance:", max.distance, "\n")
```

```{r, message=FALSE, warning=FALSE}
khat <-Kest(market_pp, rmax=28000, correction="Ripley")
khat_df <- data.frame(
  r = khat$r,             # Distance values
  iso = khat$iso,         # Observed K(r) (isotropic)
  theo = khat$theo        # Theoretical K(r)
)

ggplot(khat_df, aes(x = r)) +
  geom_line(aes(y = iso, color = "Observed K(r)"), size = 2, color = "#197278") +
  geom_line(aes(y = theo, color = "Theoretical K(r)"), linetype = "dashed", size = 1, color = "#c44536") +
  labs(
    x = "r (Distance)",
    y = "Ripley's K-Function",
    title = "Ripley's Estimated K-Function",
    color = "Legend"
  ) +
theme_light() +
theme(plot.subtitle = element_text(size = 9,face = "italic"),
        plot.title = element_text(size = 12, face = "bold"),
        axis.text.x=element_text(size=6),
        axis.text.y=element_text(size=6),
        axis.title=element_text(size=8))
```
```{r}
khat_df$difference <- khat_df$iso - khat_df$theo
threshold_index <- which(khat_df$difference > 0)[1]

if (!is.na(threshold_index)) {
  consistent_start <- khat_df$r[threshold_index]
  message("The observed K(r) is consistently higher than the theoretical K(r) starting at r = ", consistent_start)
} else {
  message("The observed K(r) does not consistently exceed the theoretical K(r) within the given range.")
}
```

```{r}
Kenv <- spatstat.explore::envelope(market_pp,fun="Kest", rmax=28000, nsim=9, nrank=1)
```
```{r}
Kenv_df <- data.frame(
  r = Kenv$r,              # Distance values
  obs = Kenv$obs,          # Observed K-function
  lower = Kenv$lo,         # Lower envelope
  upper = Kenv$hi          # Upper envelope
)

ggplot(Kenv_df, aes(x = r)) +
  geom_line(aes(y = obs, color = "Observed K(r)"), size = 2, color = "#772e25") +
  geom_line(aes(y = lower, color = "Lower Envelope"), linetype = "dashed", size = 1, color = "#197278") +
  geom_line(aes(y = upper, color = "Upper Envelope"), linetype = "dashed", size = 1, color = "#c44536") +
  labs(
    x = "r (Distance)",
    y = "Khat(r)",
    title = "Ripley's Khat with Confidence Envelopes",
    color = "Legend"
  ) +
  theme_light() +
  theme(plot.subtitle = element_text(size = 9,face = "italic"),
        plot.title = element_text(size = 12, face = "bold"),
        axis.text.x=element_text(size=6),
        axis.text.y=element_text(size=6),
        axis.title=element_text(size=8))
```
```{r}
Kenv_df$difference_lower <- Kenv_df$obs - Kenv_df$lower
first_below_index <- which(Kenv_df$difference_lower < 0)[1]

if (!is.na(first_below_index)) {
  below_start <- Kenv_df$r[first_below_index]
  message("The observed K(r) falls below the lower envelope starting at r = ", below_start)
} else {
  message("The observed K(r) does not fall below the lower envelope within the given range.")
}
```

```{r}
lhat <- Lest(market_pp, rmax=28000, correction="Ripley")

lhat_df <- data.frame(
  r = lhat$r,                      # Distance values
  L_obs = lhat$iso - lhat$r,       # Observed L-function minus r
  L_theo = lhat$theo - lhat$r      # Theoretical L-function minus r
)

ggplot(lhat_df, aes(x = r)) +
  geom_line(aes(y = L_obs, color = "Observed L(r)"), size = 2, color = "#197278") +
  geom_line(aes(y = L_theo, color = "Theoretical L(r)"), linetype = "dashed", size = 1, color = "#c44536") +
  labs(
    x = "r (Distance)",
    y = "Ripley's L - r",
    title = "Ripley's Estimated L-Function",
    color = "Legend"
  ) +
  theme_light() +
  theme(plot.subtitle = element_text(size = 9,face = "italic"),
        plot.title = element_text(size = 12, face = "bold"),
        axis.text.x=element_text(size=6),
        axis.text.y=element_text(size=6),
        axis.title=element_text(size=8))
```

```{r}
Lenv <- spatstat.explore::envelope(market_pp,fun="Lest", rmax=28000, nsim=9,nrank=1)
```

```{r}
L2 <- Lenv
L2_df <- data.frame(
  r = L2$r,                   # Distance values
  obs = L2$obs - L2$r,        # Adjusted observed L-function
  theo = L2$theo - L2$r,      # Adjusted theoretical L-function
  lo = L2$lo - L2$r,          # Lower confidence envelope
  hi = L2$hi - L2$r           # Upper confidence envelope
)

ggplot(L2_df, aes(x = r)) +
  geom_ribbon(aes(ymin = lo, ymax = hi), fill = "grey80", alpha = 0.5) +
  geom_line(aes(y = obs, color = "Observed L(r)"), size = 2, color = "#197278") +
  geom_line(aes(y = theo, color = "Theoretical L(r)"), linetype = "dashed", size = 1, color = "#c44536") +
  labs(
    x = "r (Distance)",
    y = "L(r) - r",
    title = "Ripley's L-Function with Confidence Envelopes",
    color = "Legend"
  ) +
  theme_light() +
  theme(plot.subtitle = element_text(size = 9,face = "italic"),
        plot.title = element_text(size = 12, face = "bold"),
        axis.text.x=element_text(size=6),
        axis.text.y=element_text(size=6),
        axis.title=element_text(size=8))
```
```{r}
ggplot() +
  geom_sf(data = zipcode, aes(fill = Pop2000), color = "white") +
   scale_fill_continuous(low = "#FAF9F6", high = "#c44536", name= "Population") +
  theme(
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        plot.title = element_text(size = 12, face = "bold"),
        panel.background = element_blank(),
        panel.border = element_rect(colour = "grey", fill=NA, size=0.4)
        ) +
  labs(title = "Philadelphia Population by Zip Code")
```
# Discussion

```{r}
ggplot() +
  geom_sf(data = zipcode, aes(fill = MedIncome), color = "white") +
  scale_fill_continuous(low = "#FAF9F6", high = "#197278", name = "Median Income") +
    geom_sf(data = market, aes(), color = "#c44536", size = 2) +
    theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    plot.title = element_text(size = 12, face = "bold"),
    panel.background = element_blank(),
    panel.border = element_rect(colour = "grey", fill = NA, size = 0.4)
  ) +
    labs(
    title = "Farmers Markets and Median Household Income by Zip Code")
```
